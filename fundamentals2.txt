STRICT MODE 

/* strict mode -> easier to write secure code. Can have comments before use strict 
but NOT code. */
"use strict";

/* strict creates visable errors for us, without -> javascript wouldn't let us know 
we made a mistake */

/* certain person, right now doesn't have drivers license but they've passed test */
let hasDriversLicense = false;
const passTest = true;

/* now want some logic, when they pass test, hasDriversLicense set to true */
/* if (passTest) works cause its a boolean value -> so condition is either true or false */
if (passTest) hasDriverLicense = true;
if (hasDriversLicense) console.log("I can drive");

/* with strict mode on, get Uncaught ReferenceError: hasDriverLicense is not defined */

/* use strict mode -> shortlist of varialbe names that might be added to language 
later. Shown in example below: */
const interface = "Audio";

/* code above will cause Uncaught SyntaxError: Unexpected strict mode reserved word 
(at script.js:21:7) */

/* one can't already do is 'if' */
const if = 23;

------------------------------------------------------------------------------------------------

FUNCTIONS

Part 1 - Functions: 

/* Functions = piece of code we can re use over and over again in our code */

/* Like a variable for whole chunks of code. */

/* Variable holds value. But function holds one or more complete lines of code. */

function logger() {
  /* all code in curly braces = function body. It's this code that will be executed
    when we run this function in our program. */
  console.log("my name is Tristan");
}

/* to use function - see below. This process of using the function is called invoking 
the function, running the function, or calling the function. */
logger();
logger();
logger();

/* We will get My name is Tristan three times in the console now */

Part 2 - Functions:

/* Lets explore functionality of functions */
/* When we write functions - we pass data into a function, functions can 
return data too. Can give us data back -> use for something else in the program. */

/* in function below we also express something called parameters. Parameters 
are like variables that are specific to this function. They will get defined once
we call the function. */
/* apples and oranges will be defined once the function is CALLED */
/* apples and oranges represent the input data of this function */
function fruitProcessor(apples, oranges) {
  console.log(apples, oranges);
  /* do something -> simulate - fruit processor does something with apples and oranges 
  fruit processor produces a juice out of apples and oranges we give it */
  /* Creating string that does that, variable called juice, then template literal
  then using the apples parameter here. */
  /* the apples parameter in parameters will be a number once we call the function, 
  oranges too. */
  /* we've built a string based on input data we get into the function. */
  const juice = `Juice with ${apples} apples and ${oranges} oranges`;
  /* with return keyword, can return any value from the function. This value can
  be used later anywhere in our code. */
  return juice;
}

/* Lets call / run / invoke the fruit processor function. Then in parameters, specifying
values for apples and oranges. */
/* 5 and 0 are inputs of fruit processor function. */
fruitProcessor(5, 0);

/* function fruitProcessor(apples, oranges) { } - think of apples and oranges parameters
like empty spaces we still need to fill out, when writing a function. */

/* When we call function later in code fruitProcessor(5, 0);, we fill in blank spaces,
by passing in the real specific values, which will then get assigned to the parameters. */

/* 5, 0 -> actual values of parameters are called arguments. */

/* what we're doing above is using parameters - apples and oranges just as if 
they were normal variables, just inside the fruitProcessor function. */

Part 3 - Functions: 

function fruitProcessor(apples, oranges) {
  console.log(apples, oranges);
  const juice = `Juice with ${apples} apples and ${oranges} oranges.`;
  return juice;
}

const appleJuice = fruitProcessor(5, 0);
console.log(appleJuice);

/* What about juice, where is it? Well juice is returned from function */
/* That means, result of running fruit processor function is the juice,
that we just returned. */

/* Basically, once this function has been executed, the code:
fruitProcessor(5, 0); is then replaced by the result of the function.
In this case, be the juice string we produced. */

/* So, if want to use value that was returned, we need to store it in a variable.
Save value, capture it. */

Part 4 - Functions:

function fruitProcessor(apples, oranges) {
  /* all we want to do is produce juice and return it from the function */
  const juice = `Juice with ${apples} apples and ${oranges} oranges.`;
  return juice;
}
const appleJuice = fruitProcessor(5, 0);
console.log(appleJuice);

/* calling function again. 2 and 4 are specific arguments -> will get passed 
into the function as parameters. */
/* apples and oranges are the blank spaces. Then when we call function, we fill in
these blank spaces. */
const appleOrangeJuice = fruitProcessor(2, 4);
console.log(appleOrangeJuice);

/* we should call functions at least once otherwise code in functions will never
be executed. Without calling function, it is useless. */

/*-----------------------------------------------------------------------------*/

/* logger function -> don't have any parameters, so when call function, don't specify 
any arguments. */
function logger() {
  /* note in this function nothing is returned. Not all functions return something, not all 
    functions need to accept parameters like fruit processor. */
  console.log("My name is Jonas");
  /* function without parameters or return only really use when there is a block of code we 
  want to use over and over */
}

/* this function doesn't return anything, all it does is log something to the console.
It doesn't return a value cause it doesn't return a value */
/* This is why we don't save anything to a variable cause no return, no value, nothing
to add to a variable */
/* logger() will produce undefined, and we don't capture undefined as a value. */
logger();

------------------------------------------------------------------------------------------------

FUNCTION DECLARATIONS Vs. EXPRESSIONS

/* Function Declarations */
/* Simply use the function keyword to declare function, bit like we declare varaibles */

/* function calculate age based on given birth year */
/* persons birthYear = input of function. Whats an input? Parameter in function. Parameter
is like local variable only available inside of function. */
function calcAge1(birthYear) /* then function body with curly braces */ {
  /* now code we want to create - calculate age. Current year - birthYear */
  /* can just return age calculation. Dry principle - don't need age variable. */
  return 2024 - birthYear;
}

/* calling value of parameter -> the ARGUMENT 1997 */
/* const tristanAge -> capturing value into variable */
const tristanAge = calcAge1(1997);

/*---------------------------------------------------------------------------------------*/

/* Function Expression */
/* write function without a name, then still define parameter, function body,
BUT then store it all into a variable. That variable will then be the function. */
/* function without a name -> anonymous function */
const calcAge2 = function (birthYear) {
  return 2024 - birthYear;
};
/* in function expression above everything in the fucntion to the right of the 
= is an expression. Remember expression produces a value. Use that value, store
it into calcAge2. This will then be the function. */
/* EXPRESSIONS PRODUCE VALUES. SO CALCAGE2 WILL HOLD FUNCTION VALUE */

/* to call function, we do it in same way */
const age2 = calcAge2(1991);
console.log(tristanAge, age2);

/* In javascript functions are just values. - not types. If its a value can 
store it in variable. */

/* Whats the difference function declaration and expressions?
Can call function declarations BEFORE they are defined in the code.
*/

// Function declaration
/* calling function BEFORE defined in the code */
const age1 = calcAge1(1991);

function calcAge1(birthYear) {
  return 2037 - birthYear;
}

// Function expression
/* for expressions can't call until intilisation -> cause of hoisiting */
const calcAge2 = function (birthYear) {
  return 2037 - birthYear;
};
const age2 = calcAge2(1991);

console.log(age1, age2);

/* which type should I use? personal preference -> expressions? Structure ->
forced to define functions first. Also, means functions and values are stored in 
variables */

------------------------------------------------------------------------------------------------

ARROW FUNCTIONS

/* Third type of function -> arrow function. Special type of function
expression -> shorter and therefore faster to write. */

/* Get function declaration up as comparison */
function calcAge1(birthYear) {
  return 2024 - birthYear;
}
const age1 = calcAge1(1991);

/* Get function expression up as a comparison */
const calcAge2 = function (birthYear) {
  return 2024 - birthYear;
};
const age2 = calcAge1(1997);

/* Writing an arrow function */

/* write birthYear -> then write arrow, then write what I want to return
i.e. 2024 - birthYear */
/* to use function? -> store it in variable -> const calcAge3 =  */
const calcAge3 = (birthYear) => 2024 - birthYear;

/* arrow functions -> return happens implicitly */

/* save return value into variable */
const age3 = calcAge3(1991);
console.log(age3);

/* another more complex arrow function */
/*------------------------------------------------------------------------*/
/* one parameter multiple lines of code */

/* How many years a person has left until retirement? */
/* passing in birthYear. But to calculate based on birthYear alone, first
need to calculate age, retirement age - currentAge. */
const yearsUntilRetirement = (birthYear) => {
  const currentAge = 2024 - birthYear;
  /* give us how many years we have left */
  const retirement = 65 - currentAge;
  /* to return retirement, need to write return keyword explicitly. We can 
  only ommit return if have one line function. */
  return retirement;
};
/* could assign answer to variable, but instead console.log */
console.log(yearsUntilRetirement(1997)); // 38 years

/*------------------------------------------------------------------------*/
/* multiple parameters multiple lines of code? */
/* we need to wrap parameters (variables) into parentheses */
const yearsUntilRetirement2 = (birthYear, firstName) => {
  const age = 2024 - birthYear;
  const retirementYears = 65 - age;
  return `${firstName} will retire in ${retirementYears} years.`;
};
console.log(yearsUntilRetirement2(1997, "Tristan"));

/* when should I use arrow functions? 
Have to take note of fundamental difference between arrow functions, 
function declerations and expressions */

/* arrow functions DO NOT get a so called 'this' keyword */

------------------------------------------------------------------------------------------------

FUNCTIONS CALLING OTHER FUNCTIONS

/* now consider food processor can only make juice with smaller pieces.
So before making juice, need another machine to cut the fruits we give it */
function cutFruitPieces(fruit) {
  return fruit * 4;
}

/* Go back to initial example of function producing food processor -> reviewed
a certain number of apples, certain number of oranges -> based on this produced 
and returned a juice to us. */
function fruitProcessor(apples, oranges) {
  const applePieces = cutFruitPieces(apples);
  const orangePieces = cutFruitPieces(oranges);
  const juice = `Juice with ${applePieces} apples and ${orangePieces} oranges.`;
  return juice;
}

console.log(fruitProcessor(2, 3)); // Juice with 8 apples and 12 oranges.

------------------------------------------------------------------------------------------------

REVIEWING FUNCTIONS

/* export functionality into another function -> like calcAge function.
Call one function inside of another function. */
/* So lets write another function expression */
/* don't worry about the birth year variable also being used in this function 
below. They are two different parameters or variables. */
const calcAge = function (birthYear) {
  return 2037 - birthYear;
};

/* we could even have a variable outside of the functions, could also be called
  birthYear */

/* re writing yearsTillRetirement function as regular function expression. */
const yearsUntilRetirement = function (birthYear, firstName) {
  const age = calcAge(birthYear);
  const retirement = 65 - age;
  /* take decision based on retirmenet value */
  if (retirement > 0) {
    console.log(`${firstName} retires in ${retirement} years.`);
    return retirement;
  } else {
    console.log(`${firstName} has already retired.`);
    /* In this case, if retirement is not greater than 0, the function will return -1.
    So, the purpose of returning -1 in the else block is to indicate that if retirement
    is not a positive value, it serves as a kind of "error" or "invalid" signal. */
    return -1;
  }
};
console.log(yearsUntilRetirement(1997, "Tristan"));
console.log(yearsUntilRetirement(1950, "Mike"));

/*------------------------------------------------------------------------*/

/* Functions three different tyoes */
/* declaration - function that can be used before declared. */
function calcAge(birthYear) {
  return 2037 - birthYear;
}
/* expression - essentially function values stored in variable */
const calcAge = function (birthYear) {
  return 2037 - birthYear;
};

/* arrow - great for quick one line functions. No arrow (more later). */
const calcAge = (birthYear) => 2037 - birthYear;

/* three different ways of writing functions, but all work in similar way:
input data, transform data, output data */

/* structure of common function */
/* 1. usually function needs a function name => i.e calcAge */
/* 2. Then function has parameters -> recieve input values. Like local 
variables of a function. */
/* 3. Function body: block of code that we want to reuse. Processes the
function's input data. */
/* 4. return statement - block of code that we want to re use. Processes 
the function's input data. 
Also -> return statement to output a value from the function and 
terminate execution. */
function calcAge(birthYear, firstName) {
  const age = 2037 - birthYear;
  /* console.log is just another function call inside calcAge function.
  console.log() itself is a function. So the argument we pass into console.log
  function is what will get printed to developer console. */
  console.log(`${firstName} is ${age} years old`);
  return age;
}
/* 5. Calling, running or invoking the function using () */
/* 6. Arguments inside () - actual values of function parameters, to input 
data */
/* 7. Variable to save returned value (function output) */
const age = calcAge(1991, "Jonas");

------------------------------------------------------------------------------------------------

CHALLENGE 1 - FUNCTIONS

/* Challenge 1:
Back to the two gymnastics teams, the Dolphins and the Koalas! There is a 
new gymnastics discipline, which works differently.

Each team competes 3 times, and then the average of the 3 scores is 
calculated (so one average score per team).

A team only wins if it has at least double the average score of the 
other team. Otherwise, no team wins!
*/

/*
1. Create an arrow function calcAverage to calculate the average of 3 scores. 
This function should have three parameters and return a single number 
(the average score).

2. Create two new variables — scoreDolphins and scoreKoalas, and assign 
the value returned from the calcAverage function to them (you will 
    need to call this function, and pass scores as arguments).

3. Create a function checkWinner that takes the average score of each 
team as parameters (avgDolphins and avgKoalas), and then logs the 
winner to the console, together with the victory points, according 
to the rule above. Example: Koalas win (30 vs. 13) (use avgDolphins 
    and avgKoalas instead of hard-coded values).
*/

const calcAverage = (scoreOne, scoreTwo, scoreThree) => {
  return (scoreOne + scoreTwo + scoreThree) / 3;
};

const scoreDolphins = calcAverage(150, 60, 40);
const scoreKoalas = calcAverage(250, 500, 750);

const checkWinner = function (avgDolphins, avgKoalas) {
  if (avgDolphins >= 2 * avgKoalas) {
    console.log(`Dolphins win ${avgDolphins} vs. ${avgKoalas}`);
  } else if (avgKoalas >= 2 * avgDolphins) {
    console.log(`Koalas win ${avgKoalas} vs. ${avgDolphins}`);
  } else {
    console.log(`No one wins`);
  }
};
checkWinner(scoreDolphins, scoreKoalas);

------------------------------------------------------------------------------------------------

INTRODUCTION TO ARRAYS

/* Data structure -> arrays:
Store friends names in variables -> so could use later in program. */
/* Knowledge so far, this is how we'd do it */
const friend1 = "Michael";
const friend2 = "Steven";
const friend3 = "Peter";

/* Imagine if wanted to represent 10 friends, would need 10 variables. 
Instead wouldn't it be good to bundle all of values together into a bigger 
container. */

/* Thats why we have data structures in javascript like arrays  */

/*  Arrays are big containers, in which we can throw variables and later
reference them. Programming is most of the time all about data. We get data 
from somewhere, we store and process data then we give some data back. */

/* That data has to go somewhere. It has to be stored - hence data structures
like arrays -> i.e. if we have more than a single value. */

/* Two most important data structures in JavaScript = arrays and objects */

/* create variable called friends, with []. In here we can put 
different values seperated by commas. */
/* Format should be "String", so string then comma and then another value. */
const friends = ["Michael", "Steven", "Peter"];

/* Array can hold as many values as we want and values of any type.
Doesn't have to be strings, numbers work just the same. */

/* Arrays are 0 based - first element is number 0 */
console.log(friends[0]);
console.log(friends[2]);

/* work out how long the array is? friends.length. length is a property, 
something we're going to talk about later in section when talk about objects.
'length' property is NOT 0 based, so won't be 2 even though 'Peter' is element
2 as arrays in JavaScript are 0 indexed. */
/* length will literally give us the number of elements in the array */
/* below should log 3. */
console.log(friends.length);

/* Can use this to automatically get last element of any array */
/* remember, friends.length is not 0 based, so friends.length is 3, but the last
element 'Peter' is 2 - as per the 0 indexed array */
console.log(friends[friends.length - 1]);

/* what the above also shows -> can put any expression inside of bracket. Not just number
can be an expression like 'friends.length - 1'. Remember an expression produces a value. 
Remember can't put a statement between [] */

/* friends.length - 1 will be 3 - 2 */

/* Square brackets not only for retreiving elements from the array, 
but we can also change it to add elements to the array. */

const friends = ["Michael", "Steven", "Peter"];
/* can mutuate arrays */
friends[2] = "Jay";
console.log(friends); // (3) ["Michael", "Steven", "Jay"]

/* but aren't variables declared with const unable to be changed? */
/* we declared friends variable - the array with const but we were able to 
change one element of the variable from peter to jay. */

/* Only primitive values are immutable but array is NOT primitive value. */
/* Works this way cause of how javascript stores things in memory */
/* Can mutate arrays even though declared with const. What we can't do is replace
entire array */

// friends = ["Bob", "Alice"]; // this wouldn't work

/* JavaScript -> array can hold values with different types all at the
same time. */
/* In each position, JavaScript simply expects an expression. So array below will
work. */
const jonas = ["Jonas", "Course", 2037 - 1991];

/* 2037 - 1991 will produce a value - so thats the value that will be stored at position
number 2 in the new array. */
/* This also works for variables, could also create variable name called firstName assign 
it to value Tristan then put firstName varaibale name into the array. */
const firstName = "Tristan";
const tristan = [firstName, "Griffiths", 2024 - 1997];

/* can put array inside of an array */
const friends = ["Sam", "Dan", "John"];
const firstName = "Tristan";
const tristan = [firstName, "Griffiths", 2023 - 1997, friends];

the array above in console.log will show 
(4) ["Tristan", "Griffiths", 27, Array(3)]

/* Array exercise */

/* first get calcAge function */
const calcAge = function (birthYear) {
  return 2037 - birthYear;
};

/* Lets say we have an array of birthYears, we want to calculate the ages for some of them */
const years = [1990, 1967, 2002, 2010, 2018];

/* now we will be able to use the calcAge function and then store results of calculating 
the ages for some of these years into a new array */

/* passing array to calcAge function -> the function doesn't know what to do with it */
console.log(calcAge(years)); // console.log will be NaN
/* why? the operation return 2037 - birthYear expects a single value. We cannot do a 
number - an array. So 2037 - birthYear wouldn't work if birthYear was being treated as the 
years array. */

/* we cannot do operations with arrays: */
console.log(years + 10); // 1990, 1967, 2002, 2010, 201810
console.log(years - 10); // NaN

/* but we can get single values from the array */
const age1 = calcAge(years[0]); // 1990 (this works)
const age2 = calcAge(years[1]); // 1967 (this works)
const age3 = calcAge(years[years.length - 1]); // get last value with .length - 1 trick
console.log(age1, age2, age3);

/* Take above further, started with array, good to end up with new array const ages */
/* we can put function calls into an array cause they will produce a value */
const ages = [
  calcAge(years[0]),
  calcAge(years[1]),
  calcAge(years[years.length - 1]),
];
console.log(ages);

------------------------------------------------------------------------------------------------

BASIC ARRAY OPERATIONS (METHODS)

/* Array methods -> array operations */
const friends = ["Michael", "Tristan", "Sam"];

/* ADD ELEMENTS */
// push method -> add elements onto end of array
friends.push("Jay");
/* push is a function - see that by parenthese. Its a function we call, function 
attached to the friends array itself. hence '.' */
console.log(friends); // (4) ["Michael", "Tristan", "Sam", "Jay"]

/* Push is a method, technically a function and we call it on the friends array
in the example friends.push("Jay") */

/* push() function returns a value -> thats the length of the new array.
So if want to capture that value -> can create new variable.  */
const newLength = friends.push("Jay");
console.log(newLength); // get the value 5 in the console

friends.unshift("John");
/*  The unshift method is used to add one or more elements to the beginning
of an array. */
console.log(friends); // (5) ["John", "Michael", "Steven", "Peter", "Jay"]
/* unshift also returns value -> length of array */

/* REMOVE ELEMENTS */
/* pop is opposite to push -> so remove last element of the array */
/* Don't need to pass an argument, cause no information needed to take off last 
element of an array. */
friends.pop();

/* pop method also returns something but not length of new array,
but instead it returns the removed element. */
const popped = friends.pop();
console.log(popped); // Last element (Jay) saved into popped

friends.shift(); // Takes element off the start rather than end like pop() does

/* indexOf */
const friends = ["Michael", "Steven", "Peter"];
console.log(friends.indexOf("Steven")); // 1 - cause index based.

/* includes -> instead of returning index of the element, true if
in the array, false if not. */
console.log(friends.includes("Steven")); // True
console.log(friends.includes("Joseph")); // False
/* strict equality for includes check - so if had 23 number but checked for
"23" string wouldn't work. It does strict equality. It DOES NOT do type coercion. */

/* could do */
if (friends.includes("Steven")) {
  console.log("Includes Steven.");
}

------------------------------------------------------------------------------------------------

ARRAY CHALLENGE 

/* calcTip function -> start doing it as a function expression */
/* calcBill take bill as input */
const calcTip = function (bill) {
  /* bill >= 50: Check if the bill amount is greater than or equal to 50.
300 <= 300: This condition always evaluates to true, so it doesn't affect the logic. */
  /* Then, If the bill is $50 or more, calculate a 15% tip (bill * 0.15).
If the bill is less than $50, calculate a 20% tip (bill * 0.2). */
  return bill >= 50 && 300 <= 300 ? bill * 0.15 : bill * 0.2;
};

/* could do it with arrow function as below */
/* const calcTip2 = (bill) =>
  bill >= 50 && bill <= 300 ? bill * 0.15 : bill * 0.2;
*/

/* create bills array with these three values */
const bills = [125, 555, 44];
/* tips value for each bill. Create an array, but each value a function call to calcTip */
const tips = [calcTip(bills[0]), calcTip(bills[1]), calcTip(bills[2])];

/* how do you get a total? */
const totals = [bills[0] + tips[0], bills[1] + tips[1], bills[2] + tips[2]];
/* can't do const total = bills + tips because arrays aren't values */

console.log(bills, tips, totals);

------------------------------------------------------------------------------------------------

OBJECTS

/* data structure -> combines multiple values, which all belong to tristan 
entity tristanArray */
const tristanArray = [
  "Tristan",
  "Griffiths",
  2037 - 1997,
  "Developer",
  ["Sam", "John", "Peter"],
];

/* in objects -> define key value pairs */
/* each of the keys is also called a property - so tristan object 
has 5 properties */
const tristan = {
  /* key is variable name the the value - which can be any time we want */
  firstName: "Tristan",
  lastName: "Griffiths",
  age: 2023 - 1997,
  job: "Software Developer",
  friends: ["Sam", "John", "Steven"],
};
console.log(tristan);
/* order of values doesn't matter when retrieve them, unlike arrays. 
Get properties from object, using property name itself */

------------------------------------------------------------------------------------------------

DOT Vs. BRACKET NOTATION 

/* Get properties from object, using property name itself -> explain it 
by writing out jonas object. */
const jonas = {
  firstName: "jonas",
  lastName: "Schmedtmann",
  age: 2037 - 1991,
  job: "teacher",
  friends: ["Michael", "Peter", "Steven"],
};
console.log(jonas);
/* DOT NOTATION */
/* dot . is operator go to the property with name specified */
console.log(jonas.lastName);
/* BRACKET NOTATION */
/* bracket notation in brackets can put any expression we like, so don't have
to explicitly write string, can compute it from operation. Remember operation 
is basically an expression. */
console.log(jonas["lastName"]);

const nameKey = "Name";
/* inside brackets -> could've constructed name using template literal, but not 
necessary -> see with + we can put any expression. */
console.log(jonas["first" + nameKey]);
console.log(jonas["last" + nameKey]);

/* same thing wouldn't work with dot notation 
-> this wouldn't work:
console.log(jonas."last" + nameKey)*/

/* when do you use dot notation, when do you use bracket?
When we need to first compute the property name use the bracket notation ->
i.e. "first" + nameKey, 
but in other cases use dot notation. */

/* another Bracket Notation example */
const interestedIn = prompt(
  "What do you want to know about Jonas? Choose between firstName, lastName, job and friends"
);
/* interestIn to the console, check it actually works */
/* with prompt-> if write 'job' for example and press enter, job will appear in 
the console cause thats what user chose. */
console.log(interestedIn);

/* jonas.interestedIn -> doesn't work - undefined is what we get when try and access a 
property on an object that doesn't exist. jonas doesn't have a property called interestedIn */
/* console.log(jonas.interestedIn); */

/* instead of dot notation we need to use brackets notation. javaScript will come and replace 
interestedIn with the actual value of the variable -> thats the one that will be looked up on 
a jonas object. */
console.log(jonas[interestedIn]);

/* How to handle false values not in the object? We know undefined is a falsy value. */
/* if jonas[interestedIn] means its a turthy value, any string that is not empty -> or any number
that is not 0 will trigger code block */
if (jonas[interestedIn]) {
  console.log(jonas[interestedIn]);
} else {
  console.log(
    "Wrong request. What do you want to know about Jonas? Choose between firstName, lastName, job and friends"
  );
}

/* adding to the object? */
jonas.location = "Portugal";
jonas["twitter"] = "@jonasschmedtmann";
console.log(jonas);
/* location and twitter added to object */

/* Small challenge -> Write sentence in dynamic way 
Challenge:
"Jonas has 3 friends and his best friend is called Michael." 
Michale is first friend in array in object. */
console.log(
  `${jonas.firstName} has ${jonas.friends.length} friends, and his best friend is called ${jonas.friends[0]}`
);

. dot notation
[] brackets notation are leftv to right. so jonas.friends[0] jonas.friends is done then 
[0] of friends is done 

------------------------------------------------------------------------------------------------

OBJECT METHODS

/* Objects can hold differenttypes of data, arrays and objects inside of objects. 
But now, can take it even further. */
/* Functions are really just a value. If functions are a value then that just 
means we can create a key value pair in which a value is just a function. */
/* can add functions to objects */
const jonas = {
  firstName: "Jonas",
  lastName: "Schmedtmann",
  birthYear: 1991,
  job: "teacher",
  friends: ["Michael", "Peter", "Steven"],
  /* adding a boolean */
  hasDriversLicense: true,
  /* adding function as a key value pair -> name of function as key or property. 
  calcAge not normal variable, but property of the jonas object. */
  /* any function attached to an object is called a method */
  /* method is a property */
  /* this keyword is equal to the object calling the method */
  calcAge: function () {
    console.log(this); // when log this to console, will show whole Jonas object
    /* with this.age we are essentially creating jonas.age */
    this.age = 2037 - this.birthYear;
    /* then simply return this.age -> we don't even need to return this.age we don't
    even have to make this method return the age. */
    return this.age;
  },
  getSummary: function () {
    /* in template string can do function call so calcAge() works */
    return `${this.firstName} is a ${this.calcAge()} year old ${
      this.job
    }, and he has ${this.hasDriversLicense ? "a" : "no"} drivers license.`;
  },
};

console.log(jonas.calcAge());
console.log(jonas.age);

/* any function attached to an object is called a method */
/* method is a property -> just happens to be a property that holds a function value. */

/* Get summary string -> summarise data of jonas? write out "Jonas is a 46 year old teacher,
and he has a drivers license" */
console.log(jonas.getSummary());

------------------------------------------------------------------------------------------------

OBJECT CHALLENGE
