STRICT MODE 

/* strict mode -> easier to write secure code. Can have comments before use strict 
but NOT code. */
"use strict";

/* strict creates visable errors for us, without -> javascript wouldn't let us know 
we made a mistake */

/* certain person, right now doesn't have drivers license but they've passed test */
let hasDriversLicense = false;
const passTest = true;

/* now want some logic, when they pass test, hasDriversLicense set to true */
/* if (passTest) works cause its a boolean value -> so condition is either true or false */
if (passTest) hasDriverLicense = true;
if (hasDriversLicense) console.log("I can drive");

/* with strict mode on, get Uncaught ReferenceError: hasDriverLicense is not defined */

/* use strict mode -> shortlist of varialbe names that might be added to language 
later. Shown in example below: */
const interface = "Audio";

/* code above will cause Uncaught SyntaxError: Unexpected strict mode reserved word 
(at script.js:21:7) */

/* one can't already do is 'if' */
const if = 23;

------------------------------------------------------------------------------------------------

FUNCTIONS

Part 1 - Functions: 

/* Functions = piece of code we can re use over and over again in our code */

/* Like a variable for whole chunks of code. */

/* Variable holds value. But function holds one or more complete lines of code. */

function logger() {
  /* all code in curly braces = function body. It's this code that will be executed
    when we run this function in our program. */
  console.log("my name is Tristan");
}

/* to use function - see below. This process of using the function is called invoking 
the function, running the function, or calling the function. */
logger();
logger();
logger();

/* We will get My name is Tristan three times in the console now */

Part 2 - Functions:

/* Lets explore functionality of functions */
/* When we write functions - we pass data into a function, functions can 
return data too. Can give us data back -> use for something else in the program. */

/* in function below we also express something called parameters. Parameters 
are like variables that are specific to this function. They will get defined once
we call the function. */
/* apples and oranges will be defined once the function is CALLED */
/* apples and oranges represent the input data of this function */
function fruitProcessor(apples, oranges) {
  console.log(apples, oranges);
  /* do something -> simulate - fruit processor does something with apples and oranges 
  fruit processor produces a juice out of apples and oranges we give it */
  /* Creating string that does that, variable called juice, then template literal
  then using the apples parameter here. */
  /* the apples parameter in parameters will be a number once we call the function, 
  oranges too. */
  /* we've built a string based on input data we get into the function. */
  const juice = `Juice with ${apples} apples and ${oranges} oranges`;
  /* with return keyword, can return any value from the function. This value can
  be used later anywhere in our code. */
  return juice;
}

/* Lets call / run / invoke the fruit processor function. Then in parameters, specifying
values for apples and oranges. */
/* 5 and 0 are inputs of fruit processor function. */
fruitProcessor(5, 0);

/* function fruitProcessor(apples, oranges) { } - think of apples and oranges parameters
like empty spaces we still need to fill out, when writing a function. */

/* When we call function later in code fruitProcessor(5, 0);, we fill in blank spaces,
by passing in the real specific values, which will then get assigned to the parameters. */

/* 5, 0 -> actual values of parameters are called arguments. */

/* what we're doing above is using parameters - apples and oranges just as if 
they were normal variables, just inside the fruitProcessor function. */

Part 3 - Functions: 

function fruitProcessor(apples, oranges) {
  console.log(apples, oranges);
  const juice = `Juice with ${apples} apples and ${oranges} oranges.`;
  return juice;
}

const appleJuice = fruitProcessor(5, 0);
console.log(appleJuice);

/* What about juice, where is it? Well juice is returned from function */
/* That means, result of running fruit processor function is the juice,
that we just returned. */

/* Basically, once this function has been executed, the code:
fruitProcessor(5, 0); is then replaced by the result of the function.
In this case, be the juice string we produced. */

/* So, if want to use value that was returned, we need to store it in a variable.
Save value, capture it. */

Part 4 - Functions:

function fruitProcessor(apples, oranges) {
  /* all we want to do is produce juice and return it from the function */
  const juice = `Juice with ${apples} apples and ${oranges} oranges.`;
  return juice;
}
const appleJuice = fruitProcessor(5, 0);
console.log(appleJuice);

/* calling function again. 2 and 4 are specific arguments -> will get passed 
into the function as parameters. */
/* apples and oranges are the blank spaces. Then when we call function, we fill in
these blank spaces. */
const appleOrangeJuice = fruitProcessor(2, 4);
console.log(appleOrangeJuice);

/* we should call functions at least once otherwise code in functions will never
be executed. Without calling function, it is useless. */

/*-----------------------------------------------------------------------------*/

/* logger function -> don't have any parameters, so when call function, don't specify 
any arguments. */
function logger() {
  /* note in this function nothing is returned. Not all functions return something, not all 
    functions need to accept parameters like fruit processor. */
  console.log("My name is Jonas");
  /* function without parameters or return only really use when there is a block of code we 
  want to use over and over */
}

/* this function doesn't return anything, all it does is log something to the console.
It doesn't return a value cause it doesn't return a value */
/* This is why we don't save anything to a variable cause no return, no value, nothing
to add to a variable */
/* logger() will produce undefined, and we don't capture undefined as a value. */
logger();

------------------------------------------------------------------------------------------------

FUNCTION DECLARATIONS Vs. EXPRESSIONS

/* Function Declarations */
/* Simply use the function keyword to declare function, bit like we declare varaibles */

/* function calculate age based on given birth year */
/* persons birthYear = input of function. Whats an input? Parameter in function. Parameter
is like local variable only available inside of function. */
function calcAge1(birthYear) /* then function body with curly braces */ {
  /* now code we want to create - calculate age. Current year - birthYear */
  /* can just return age calculation. Dry principle - don't need age variable. */
  return 2024 - birthYear;
}

/* calling value of parameter -> the ARGUMENT 1997 */
/* const tristanAge -> capturing value into variable */
const tristanAge = calcAge1(1997);

/*---------------------------------------------------------------------------------------*/

/* Function Expression */
/* write function without a name, then still define parameter, function body,
BUT then store it all into a variable. That variable will then be the function. */
/* function without a name -> anonymous function */
const calcAge2 = function (birthYear) {
  return 2024 - birthYear;
};
/* in function expression above everything in the fucntion to the right of the 
= is an expression. Remember expression produces a value. Use that value, store
it into calcAge2. This will then be the function. */
/* EXPRESSIONS PRODUCE VALUES. SO CALCAGE2 WILL HOLD FUNCTION VALUE */

/* to call function, we do it in same way */
const age2 = calcAge2(1991);
console.log(tristanAge, age2);

/* In javascript functions are just values. - not types. If its a value can 
store it in variable. */

/* Whats the difference function declaration and expressions?
Can call function declarations BEFORE they are defined in the code.
*/

// Function declaration
/* calling function BEFORE defined in the code */
const age1 = calcAge1(1991);

function calcAge1(birthYear) {
  return 2037 - birthYear;
}

// Function expression
/* for expressions can't call until intilisation -> cause of hoisiting */
const calcAge2 = function (birthYear) {
  return 2037 - birthYear;
};
const age2 = calcAge2(1991);

console.log(age1, age2);

/* which type should I use? personal preference -> expressions? Structure ->
forced to define functions first. Also, means functions and values are stored in 
variables */

------------------------------------------------------------------------------------------------

ARROW FUNCTIONS

/* Third type of function -> arrow function. Special type of function
expression -> shorter and therefore faster to write. */

/* Get function declaration up as comparison */
function calcAge1(birthYear) {
  return 2024 - birthYear;
}
const age1 = calcAge1(1991);

/* Get function expression up as a comparison */
const calcAge2 = function (birthYear) {
  return 2024 - birthYear;
};
const age2 = calcAge1(1997);

/* Writing an arrow function */

/* write birthYear -> then write arrow, then write what I want to return
i.e. 2024 - birthYear */
/* to use function? -> store it in variable -> const calcAge3 =  */
const calcAge3 = (birthYear) => 2024 - birthYear;

/* arrow functions -> return happens implicitly */

/* save return value into variable */
const age3 = calcAge3(1991);
console.log(age3);

/* another more complex arrow function */
/*------------------------------------------------------------------------*/
/* one parameter multiple lines of code */

/* How many years a person has left until retirement? */
/* passing in birthYear. But to calculate based on birthYear alone, first
need to calculate age, retirement age - currentAge. */
const yearsUntilRetirement = (birthYear) => {
  const currentAge = 2024 - birthYear;
  /* give us how many years we have left */
  const retirement = 65 - currentAge;
  /* to return retirement, need to write return keyword explicitly. We can 
  only ommit return if have one line function. */
  return retirement;
};
/* could assign answer to variable, but instead console.log */
console.log(yearsUntilRetirement(1997)); // 38 years

/*------------------------------------------------------------------------*/
/* multiple parameters multiple lines of code? */
/* we need to wrap parameters (variables) into parentheses */
const yearsUntilRetirement2 = (birthYear, firstName) => {
  const age = 2024 - birthYear;
  const retirementYears = 65 - age;
  return `${firstName} will retire in ${retirementYears} years.`;
};
console.log(yearsUntilRetirement2(1997, "Tristan"));

/* when should I use arrow functions? 
Have to take note of fundamental difference between arrow functions, 
function declerations and expressions */

/* arrow functions DO NOT get a so called 'this' keyword */

------------------------------------------------------------------------------------------------

FUNCTIONS CALLING OTHER FUNCTIONS

/* now consider food processor can only make juice with smaller pieces.
So before making juice, need another machine to cut the fruits we give it */
function cutFruitPieces(fruit) {
  return fruit * 4;
}

/* Go back to initial example of function producing food processor -> reviewed
a certain number of apples, certain number of oranges -> based on this produced 
and returned a juice to us. */
function fruitProcessor(apples, oranges) {
  const applePieces = cutFruitPieces(apples);
  const orangePieces = cutFruitPieces(oranges);
  const juice = `Juice with ${applePieces} apples and ${orangePieces} oranges.`;
  return juice;
}

console.log(fruitProcessor(2, 3)); // Juice with 8 apples and 12 oranges.

------------------------------------------------------------------------------------------------

REVIEWING FUNCTIONS

/* export functionality into another function -> like calcAge function.
Call one function inside of another function. */
/* So lets write another function expression */
/* don't worry about the birth year variable also being used in this function 
below. They are two different parameters or variables. */
const calcAge = function (birthYear) {
  return 2037 - birthYear;
};

/* we could even have a variable outside of the functions, could also be called
  birthYear */

/* re writing yearsTillRetirement function as regular function expression. */
const yearsUntilRetirement = function (birthYear, firstName) {
  const age = calcAge(birthYear);
  const retirement = 65 - age;
  /* take decision based on retirmenet value */
  if (retirement > 0) {
    console.log(`${firstName} retires in ${retirement} years.`);
    return retirement;
  } else {
    console.log(`${firstName} has already retired.`);
    /* In this case, if retirement is not greater than 0, the function will return -1.
    So, the purpose of returning -1 in the else block is to indicate that if retirement
    is not a positive value, it serves as a kind of "error" or "invalid" signal. */
    return -1;
  }
};
console.log(yearsUntilRetirement(1997, "Tristan"));
console.log(yearsUntilRetirement(1950, "Mike"));

/*------------------------------------------------------------------------*/

/* Functions three different tyoes */
/* declaration - function that can be used before declared. */
function calcAge(birthYear) {
  return 2037 - birthYear;
}
/* expression - essentially function values stored in variable */
const calcAge = function (birthYear) {
  return 2037 - birthYear;
};

/* arrow - great for quick one line functions. No arrow (more later). */
const calcAge = (birthYear) => 2037 - birthYear;

/* three different ways of writing functions, but all work in similar way:
input data, transform data, output data */

/* structure of common function */
/* 1. usually function needs a function name => i.e calcAge */
/* 2. Then function has parameters -> recieve input values. Like local 
variables of a function. */
/* 3. Function body: block of code that we want to reuse. Processes the
function's input data. */
/* 4. return statement - block of code that we want to re use. Processes 
the function's input data. 
Also -> return statement to output a value from the function and 
terminate execution. */
function calcAge(birthYear, firstName) {
  const age = 2037 - birthYear;
  /* console.log is just another function call inside calcAge function.
  console.log() itself is a function. So the argument we pass into console.log
  function is what will get printed to developer console. */
  console.log(`${firstName} is ${age} years old`);
  return age;
}
/* 5. Calling, running or invoking the function using () */
/* 6. Arguments inside () - actual values of function parameters, to input 
data */
/* 7. Variable to save returned value (function output) */
const age = calcAge(1991, "Jonas");

------------------------------------------------------------------------------------------------

CHALLENGE 1 - FUNCTIONS

/* Challenge 1:
Back to the two gymnastics teams, the Dolphins and the Koalas! There is a 
new gymnastics discipline, which works differently.

Each team competes 3 times, and then the average of the 3 scores is 
calculated (so one average score per team).

A team only wins if it has at least double the average score of the 
other team. Otherwise, no team wins!
*/

/*
1. Create an arrow function calcAverage to calculate the average of 3 scores. 
This function should have three parameters and return a single number 
(the average score).

2. Create two new variables — scoreDolphins and scoreKoalas, and assign 
the value returned from the calcAverage function to them (you will 
    need to call this function, and pass scores as arguments).

3. Create a function checkWinner that takes the average score of each 
team as parameters (avgDolphins and avgKoalas), and then logs the 
winner to the console, together with the victory points, according 
to the rule above. Example: Koalas win (30 vs. 13) (use avgDolphins 
    and avgKoalas instead of hard-coded values).
*/

const calcAverage = (scoreOne, scoreTwo, scoreThree) => {
  return (scoreOne + scoreTwo + scoreThree) / 3;
};

const scoreDolphins = calcAverage(150, 60, 40);
const scoreKoalas = calcAverage(250, 500, 750);

const checkWinner = function (avgDolphins, avgKoalas) {
  if (avgDolphins >= 2 * avgKoalas) {
    console.log(`Dolphins win ${avgDolphins} vs. ${avgKoalas}`);
  } else if (avgKoalas >= 2 * avgDolphins) {
    console.log(`Koalas win ${avgKoalas} vs. ${avgDolphins}`);
  } else {
    console.log(`No one wins`);
  }
};
checkWinner(scoreDolphins, scoreKoalas);

------------------------------------------------------------------------------------------------

INTRODUCTION TO ARRAYS

/* Data structure -> arrays:
Store friends names in variables -> so could use later in program. */
/* Knowledge so far, this is how we'd do it */
const friend1 = "Michael";
const friend2 = "Steven";
const friend3 = "Peter";

/* Imagine if wanted to represent 10 friends, would need 10 variables. 
Instead wouldn't it be good to bundle all of values together into a bigger 
container. */

/* Thats why we have data structures in javascript like arrays  */

/*  Arrays are big containers, in which we can throw variables and later
reference them. Programming is most of the time all about data. We get data 
from somewhere, we store and process data then we give some data back. */

/* That data has to go somewhere. It has to be stored - hence data structures
like arrays -> i.e. if we have more than a single value. */

/* Two most important data structures in JavaScript = arrays and objects */